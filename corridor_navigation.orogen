name "corridor_navigation"
version "0.1"

using_library "vfh_star"
#using_library "asguard"
using_library 'corridor_navigation'
using_library 'velodyne_lidar'
import_types_from "base"
import_types_from "corridor_planner"
import_types_from "envire"

import_types_from "vfh_star/Types.h"
import_types_from "vfh_star/TreeSearch.h"
import_types_from "vfh_star/DebugTypes.h"
import_types_from "corridor_navigation/VFHFollowingConf.hpp"
import_types_from "corridor_navigation/VFHServoingConf.hpp"
import_types_from "corridor_navigation/VFHStarDebugData.hpp"
import_types_from "corridorNavigationTypes.hpp"
import_types_from "velodyne_lidar/MultilevelLaserScan.h"

typekit.opaque_type '/vfh_star/Tree', 'wrappers/vfh_star/Tree'

task_context "ServoingTask" do
    input_port("scan_samples", "base/samples/LaserScan").
	needs_reliable_connection.
        doc "LaserScann of front Scanner"

    input_port("scan_samples_back", "base/samples/LaserScan").
	needs_reliable_connection.
        doc "Optional LaserScann of rear scanner"

    input_port("velodyne_scans", "velodyne_lidar::MultilevelLaserScan").
	needs_reliable_connection.
        doc 'Optional velodyne scans'

    input_port('heading', 'double').
	doc 'differential heading in NWU, where the robot should drive'

    input_port('absolute_heading', 'double').
	doc 'heading in NWU, where the robot should drive'

    output_port("segmented", "bool").
	doc "debug port for log replay"

    output_port("trajectory", "std::vector</base/Trajectory>")

    output_port("gridDump", "vfh_star/GridDump")

    output_port("vfhDebug", "corridor_navigation/VFHStarDebugData")

    output_port('debugVfhTree', '/vfh_star/Tree').
        doc 'the resulting internal search tree'

    output_port('debug_laser_frame', '/base/samples/RigidBodyState').
	    doc 'debug frame. This is the frame of the laser scan in respect to the map.'
	   
    output_port('debug_heading_frame', '/base/samples/RigidBodyState').
	    doc 'Debug frame describing the heading orientation'

    output_port('debug_sweep_status','int').
        doc 'Current tracked sweep angle'	   

    output_port('count_no_trajectory','int').
        doc 'Counter of the number of times in a row that no trajectory cannot be found even if the searching area is not unknown'	   

    output_port('count_unknown_trajectory','int').
        doc 'Counter of the number of times in a row that no trajectory cannot be found beacuase of passing through unknown area'	   

    operation('setMap').
	argument('map', 'std/vector</envire/BinaryEvent>').
	argument('mapId', 'std/string').
	argument('mapPose', '/base/samples/RigidBodyState').
	returns('bool')
	doc("Sets an apriori map of the environment of the robot. This function must be be called prior to starting the component.")

    ##########################
    # transformer parameters
    ##########################

    transformer do
	transformation("body_center", "body")
	transformation("body_center", "odometry")
	transformation("laser", "body_center")
        transformation("laser_back", "body_center")
        transformation("velodyne", "body_center")
	align_port('scan_samples', 0.025)
	align_port('scan_samples_back', 0.025)
	align_port('velodyne_scans', 0.08)

	max_latency(0.1)
    end

    property('search_conf', '/vfh_star/TreeSearchConf').
        doc('Parametrization of the search')
    property('cost_conf', '/corridor_navigation/VFHServoingConf').
        doc('Parametrization of the cost function')
    property('search_horizon', 'double').
        doc 'the search horizon, in meters'
    property('fail_count',  'int32_t', 1).
    	doc('The number of times in a row where no trajectorie could be computed, that makes the task fail')
    property('unknown_retry_count',  'int32_t', 2).
    	doc('In case the trajectorie goes through unknown terrain, it is cut. This parameter defines how often the task will wait for a sensor sweep to complete before failing.')
    property('x_forward', 'bool', true).
        doc('for backward compatibility only. Set to false to use the Y-forward convention. Rock uses a X-forward convention')
    property('allowBackwardsDriving', 'bool', true).
        doc('This property specifies if the robot is allowed to drive backwards')
    property('height_to_ground', 'double', 0).
        doc 'the distance between the body frame and the ground'
    property('front_shadow_distance','double',0.0).
        doc 'the region in front of the laser the laser cannot scan. (if <= 0 it will be computed from the tilt angle)'
    property('entry_window_size', 'int', 30).
        doc 'Maximum number of measures that are taken into accound when '+
          'constructing a cel of the occupancy grid.'
    property('entry_height_conf', 'int', 0).
        doc 'Method for constructing each cell height from all the perceived' +
          ' measures. Codes: 0 - mean, 1 - mean+0.5*std, 2 - median.'
    property('replanning_delay', 'double', 10).
        doc 'Minimal time in seconds to wait until another replanning is allowed'
    property('min_trajectory_lenght', 'double', 0.2).
        doc('Minimal length of the output trajectory. The planned trajectory gets cut if it goes through unknown terrain.').
        doc("If the resulting trjacetory length is smaler than this parameter an trajectory_through_unknown error will be generated")
    property('allow_planning', 'bool', true).
        doc 'setting this value to false disables the planning. Pretty usefull for traversability parameter tuning'
    property('allow_exception', 'bool', true).
        doc 'setting this value to false disables the exception states in case the planner did not find a solution. Pretty usefull for parameter tuning on log data'

    ## velodyne filter parameter
    property('velodyne_maximum_angle_to_neighbor', 'double', 2.53).
        doc('valid neigbors have an angle not greater than this value.').
        doc('the angle is always defined from the origin to the more distant point.')
    property('velodyne_minimum_valid_neighbors', 'int', 2).
        doc('minimum amount of valid neigbors')
        

    exception_states :no_solution, :trajectory_through_unknown

    needs_configuration
    port_driven 'scan_samples'
    worstcase_processing_time 0.3	
end

task_context "FollowingTask" do
    doc "This task makes the robot cross a given corridor structure, from its beginning to its end"

    property('search_conf',  'vfh_star::TreeSearchConf')
    property('cost_conf',    'corridor_navigation::VFHFollowingConf')
    property('search_horizon', 'double').
        doc 'the search horizon, in meters'

    input_port('problem', '/corridor_navigation/CorridorFollowingProblem').
        doc 'the corridor following problem'

    input_port('pose_samples', '/base/samples/RigidBodyState').
        doc 'the current robot pose'

    output_port('trajectory', 'std::vector</base/Trajectory>').
        doc 'the generated trajectory'

    output_port('debugVfhTree', '/vfh_star/Tree').
        doc 'the resulting internal search tree'

    output_port('debug', '/corridor_navigation/FollowingDebug').
        doc 'the resulting state of the planner'

    exception_states :DEAD_END, :NO_VIABLE_PATH
    port_driven 'pose_samples'
end

task_context "PoseAlignmentTask" do
    input_port('target_pose', '/base/Pose').
        doc 'the target pose after final alignment'

    output_port('motion_commands', '/base/MotionCommand2D')
        doc 'motion commands to perform the alignment'

    transformer do
        transformation('body','world')
        transformation("body", "odometry")
        max_latency(0.1)
    end

    property('turn_speed',  'double', 0.0)
    property('forward_speed',  'double', 0.0)
    property('min_distance_to_target',  'double', 0.0)
        .doc("If the robot is less than this distance away from the target position, it will assume it reached it")
    property('min_alginment_angle',  'double', 0.0)
        .doc("The precision of the alignement the robot will try to achive")
    property('retry_distance',  'double', 0.0)
        .doc("If the robot is more than the retry distance away from the target, it will
              realign to the target position and try driving there again")

    exception_states :TOO_FAR_FROM_TARGET

    periodic 0.1
end

task_context "TestTask" do
    property('test_conf', 'corridor_navigation::TestConf')
    property('search_conf',  'vfh_star::TreeSearchConf')
    property('cost_conf',    'vfh_star::VFHStarConf')
    property('initial_pose', 'base/Pose')
    property('search_horizon', 'double', 2.0).
        doc 'the search horizon, in meters'

    output_port('trajectory', '/base/geometry/Spline<3>')
    output_port('search_tree', '/vfh_star/Tree')
end

deployment "corridorNavigationTest" do
    task('corridor_servoing', "corridor_navigation::ServoingTask").
	triggered
    task('corridor_following', "corridor_navigation::FollowingTask").
	triggered
    task('vfh_search_test', "corridor_navigation::TestTask").
	triggered

    add_default_logger
end

